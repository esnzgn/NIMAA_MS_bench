
---
title: "EDA of WOMBAT-P Proteomics Data"
output: html_document
author: Ehsan Zangene
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## üì¶ Load Required Libraries

```{r}
# rm(list = ls())

# install.packages("remotes")
# remotes::install_github("VoisinneG/queryup")
library(queryup)
library(httr)
library(jsonlite)
library(readr)
library(purrr)
library(tibble)
library(tidyverse)
library(ggplot2)
```

## üìÅ Define Data Directory and Read Files

```{r}
data_dir <- "../../WOMBAT-P_Processed/ProteoBenchDDA/0.9.11/"

# List all files
all_files <- list.files(data_dir, full.names = TRUE)

# Split by type
csv_files <- all_files[grepl("\\.(csv)$", all_files)]
json_files <- all_files[grepl("\\.(json)$", all_files)]

# Read files
csv_data <- setNames(lapply(csv_files, read_csv), basename(csv_files))
json_data <- setNames(lapply(json_files, fromJSON), basename(json_files))
```

## üßæ Function to Print Metadata

```{r}
print_metadata <- function(data_list, type = "CSV") {
  cat("\n===== Metadata for", type, "files =====\n")
  for (name in names(data_list)) {
    cat("\n---", name, "---\n")
    df <- data_list[[name]]
    if (is.data.frame(df)) {
      cat("Dimensions:", paste(dim(df), collapse = " x "), "\n")
      cat("Column names:", paste(colnames(df), collapse = ", "), "\n")
      cat("First few row names / IDs:", paste(rownames(df)[1:min(5, nrow(df))], collapse = ", "), "\n")
    } else {
      cat("Not a data frame. Type:", class(df), "\n")
      cat("length is: ", length(df), "\n")
      cat("including: ", names(df), "\n")
    }
  }
}
```

## üìÑ Print Metadata


```{r}
csv_data_log <- csv_data$stand_pep_quant_mergedcompomics.csv %>%
  mutate(across(starts_with("abundance_"), ~log2(.x + 1)))  # add 1 to avoid log(0)

csv_data_log %>% 
  select(starts_with("abundance_")) %>% 
summary()
```
```{r}
tibble(csv_data$stand_ion_quant_mergedcompomics.csv) %>% 
  select(starts_with("abundance_")) %>% 
  summary()

```

```{r}
# Pivot to long format
for (i in (grep("stand_pep_quant",names(csv_data)))){
  tmptbl = NULL
  df_long = NULL
  # head(tibble(csv_data[[i]]))
  tmptbl <- csv_data[[i]]
  
  df_long <- tmptbl %>%
  pivot_longer(
    cols = starts_with("abundance_"),
    names_to = "sample",
    values_to = "abundance"
  )  

  p1 <- ggplot(data = df_long, aes(x = sample, y = abundance, fill = sample)) +
      geom_boxplot(alpha = .7) +
    # coord_flip() +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          legend.position = "none")
  
  # 
  # df_long <- df_long %>% 
  #   mutate(across("abundance", ~log2(.x + 1)))

  p2 <- ggplot(data = df_long, aes(x = sample, y = log2(abundance + 1), fill = sample)) +
      geom_boxplot(alpha = .7) +
    # coord_flip() +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none")

  # legend <- cowplot::get_legend(p1)
  # p1 <- p1 + theme(legened.position = "none")
  p <- cowplot::plot_grid(p1, p2, ncol = 1, labels = gsub("stand_pep_quant_","",names(csv_data[i])))
    print(p)
}
# 
# 
# csv_data_log %>%
#   pivot_longer(cols = starts_with("abundance_"), names_to = "sample", values_to = "log2_abundance") %>%
#   ggplot(aes(x = sample, y = log2_abundance)) +
#   geom_boxplot(outlier.shape = NA) +
#   coord_flip() +
#   theme_minimal()
# 
# 
# print_metadata(csv_data, "CSV")
# print_metadata(json_data, "JSON")
```
# question: why some peps have no psm mapped but on the other hand there some abundance values (to ve asked form fight)
## e.g. P07259 in maxquant pep csv psm vs abundance
!["quesiotn for fight"](../image/qustions_raised_fight.jpg)

## üìä Sample Exploratory Plots from CSV (if applicable)

```{r df_4_NIMAA func def}
# to use this func first we need an additonal func to let the user chose the column for rownames and columns that need to stay as the cols
# and also rm the duplicated var chosen for rownames with some logic (least NA including)

source("../script/funcs4_nimaa_analysis.R") 
# if (length(csv_data) > 0) {
#   sample_df <- csv_data[[1]]
#   if (is.data.frame(sample_df)) {
#     summary(sample_df)
#     hist_df <- sample_df[, sapply(sample_df, is.numeric)]
#     if (ncol(hist_df) > 0) {
#       hist(hist_df[[1]], main = "Histogram of first numeric column", xlab = names(hist_df)[1])
#     }
#   }
# }
```

## NIMAA analysis on NA's of WomBat datasets
!["NIMAA workflow"](../image/NIMAA_GA.jpg)

```{r NIMAA}
library(NIMAA)

# nominalAsBinet()

# beatAML is a long format dataset existing NIMAA
# beatAML_data <- NIMAA::beatAML[1:1000,]

# convert to incidence matrix or actually the wide format of real data
# beatAML_incidence_matrix <- nominalAsBinet(beatAML_data)

# extract submatrices with non-missing values
# sub_matrices <- extractSubMatrix(beatAML_incidence_matrix, col.vars = "patient_id",
#  row.vars = "inhibitor")
seqq = (grep("stand_prot_quant_",names(csv_data)))
source("extra fucs.R")
# 
# # Example test
# test_ids <- c("P22682", "P47941", "Q9H2L4")
# get_uniprot_organisms(test_ids)
uniprot_ids <- NULL

for (i in seqq){
  print(i)
  tmptbl = NULL
  df_long = NULL
  # head(tibble(csv_data[[i]]))
  rm(nm)
  nm <- names(csv_data[i])
  tmptbl <- csv_data[[i]]
  cat("dataset name: ", nm, " ----- dim: ", dim(tmptbl), " \n")
  # print(colnames(tmptbl))
  read4_nimaa <- df_4_NIMAA(tmptbl, column_to_row = "protein_group", if_protein = T, pattern_to_columns = c("peptides_A", "peptides_B")) 
  print(class(read4_nimaa))
  print(dim(read4_nimaa))
  print(head(read4_nimaa))
  print(rownames(read4_nimaa)[1:10])
  # origanism
  # Build and run the query
  #  usage with my read4_nimaa rownames
  uniprot_ids <- c(uniprot_ids, as.character(rownames(read4_nimaa)))
  
  cat("--------> done: ", nm, paste(rep("-------",3), collapse = ""), "\n")
}

library(dplyr)
library(tidyr)

uniprot_ids <- uniprot_ids %>%
  # Turn into tibble
  tibble(id = .) %>%
  # Separate by comma into rows
  separate_rows(id, sep = ",") %>%
  # Remove duplicates and clean spaces
  mutate(id = trimws(id)) %>%
  distinct() %>%
  pull(id)

uniprot_ids
# some come with a prefix as "cont_"
# [199] "O15143"      "P60660"      "Q9BV44"      "Q2VPK5"      "Cont_P60712" "P60709"  

# result_organism_1 <- get_uniprot_organisms(uniprot_ids[1:2000], batch_size = 100)
# result_organism_2 <- get_uniprot_organisms(uniprot_ids[2001:3220], batch_size = 100)
# result_organism_3 <- get_uniprot_organisms(uniprot_ids[3221:3228], batch_size = 100)
# result_organism_4 <- get_uniprot_organisms(uniprot_ids[3230:6000], batch_size = 100)
# result_organism_5 <- get_uniprot_organisms(uniprot_ids[6001:6450], batch_size = 100)
# result_organism_6 <- get_uniprot_organisms(uniprot_ids[6451:6483], batch_size = 100)
# result_organism_7 <- get_uniprot_organisms(uniprot_ids[6485:6907], batch_size = 100)
# 
# result_organism <- rbind(result_organism_1, result_organism_2, 
#                          result_organism_3, result_organism_4,
#                          result_organism_5, result_organism_6,
#                          result_organism_7)
# uniprot_ids[3229] = "A0A0B4J2D5" , uniprot_ids[6484] = "A9Z1Z3"
# This entry is no longer annotated in UniProtKB and can be found in UniParc.
# Reason: Deleted from Swiss-Prot
# Since release: 2024_06/2024_06



# result_organism <- get_uniprot_organisms(uniprot_ids, batch_size = 100)
# # result_organism <- rbind(result_organism_1_1000, result_organism_1001_3000, result_organism_3001_4000, result_organism_4001_5000, result_organism_5001_6000, result_organism_6001_6449, result_organism_6451_6743)
# 
# result_organism %>% 
#   count(organism, name = "freq") %>% 
#   arrange(desc(freq))
# 
# write.csv(result_organism, "../output/uniprot_organism_map.csv")
result_organism <- read.csv("../output/uniprot_organism_map.csv", row.names = 1)

unkn_source <- list(contamination = "Cont_",
                 uniParc = c("A9Z1Z3", "A0A0B4J2D5"),
                 Multiple_ids = ","
                )
```

```{r}
seqq <- grep("stand_prot", names(csv_data))
subMat = NULL

# Set up the cluster
# n_cores <- 8
# cl <- makeCluster(n_cores)
#
# # Manually define the path INSIDE the cluster
# clusterEvalQ(cl, {
#   user_lib <- file.path(Sys.getenv("HOME"), "R", "x86_64-pc-linux-gnu-library", paste0(R.version$major, ".", R.version$minor))
#   .libPaths(c(user_lib, .libPaths()))
# })
#
# # Register the parallel backend
# registerDoParallel(cl)

# subMat <- foreach(i = seqq, .packages = c("tidyverse", "NIMAA")) %dopar% {
idss <- data_frame(NULL)

# Palette for organisms (pick 4 distinct colors)
org_pal <- c(
  "Homo s" = "#1f77b4",
  "Saccha" = "#2ca02c",
  "Escher" = "#d62728",
  "Unknown" = "#7f7f7f"
)

source("../script/extractSubMatrix_complete.R")

for (i in seqq){
  nm <- names(csv_data[i])
  tmptbl <- csv_data[[i]]

  new_df <- tmptbl %>%
    select(contains(c("number_of_peptides_A", "number_of_peptides_B")))

  if (grepl("stand_prot_quant_mergedmaxquant.csv",nm)){
    for (col_i in 1:ncol(new_df)){
      zero_ids <- which(new_df[, col_i] == 0)
      new_df[zero_ids, col_i] <- NA
    }
  }

  result <- extractSubMatrix_complete(
    as.matrix(new_df),
    shape = "Rectangular_element_max",
    col.vars = "samples",
    row.vars = "peptides"
  )

  ids_dropped <- result$Rectangular_element_max_dropped %>%
    as.data.frame() %>%
    rownames() %>%
    as.integer()

  y_axis_ids <- result$Rectangular_element_max %>%
    as.data.frame() %>%
    colnames() %>% 
    rev()
  
  # find("extractSubMatrix")
  # body(extractSubMatrix)
  # utils::page("extractSubMatrix")

  ids <-  result$Rectangular_element_max %>%
          as.data.frame() %>%
          rownames() %>%
          as.integer()

  prot_ls <- tmptbl$protein_group[ids]
  prot_ls_dropped <- tmptbl$protein_group[ids_dropped]

  mult_ids_max <- which(grepl(",", prot_ls))
  mult_ids_max_dropped <- which(grepl(",", prot_ls_dropped))
  
  idx_org <- match(prot_ls, result_organism$accession)
  organisms <- result_organism$organism[idx_org]

  idx_org_drp <- match(prot_ls_dropped, result_organism$accession)
  organisms_drp <- result_organism$organism[idx_org_drp]
  
  for (ids_i in seq_along(mult_ids_max)){
    curr_id <- (mult_ids_max[ids_i])
    ids_sep <- strsplit(prot_ls[curr_id], ",") %>%
      unlist()
    org_ids <- match(ids_sep, result_organism$accession)
    feq_res <- table(result_organism$organism[org_ids])
    if (length(feq_res) > 0){
    organisms[curr_id] <- names(which.max(feq_res))}
  }

  for (ids_i in seq_along(mult_ids_max_dropped)){
    curr_id <- (mult_ids_max_dropped[ids_i])
    ids_sep <- strsplit(prot_ls_dropped[curr_id], ",") %>%
      unlist()
    org_ids <- match(ids_sep, result_organism$accession)
    feq_res <- table(result_organism$organism[org_ids])
    if(length(feq_res) > 0){
      organisms_drp[curr_id] <- names(which.max(feq_res))
    }
  }
  
  organisms <- substr(organisms, 1, 6)
  organisms_drp <- substr(organisms_drp, 1, 6)
  
  forheat <- result$Rectangular_element_max %>%
    as.data.frame() %>%
    cbind(organisms)

  org_vec <- organisms_drp
  org_vec[is.na(org_vec)] <- "NA"
  df <- data.frame(row_id = seq_along(org_vec), organism = org_vec)

  # Make sure NA is labeled
  # forheat <- forheat %>%
  #   mutate(organisms = ifelse(is.na(organisms), "Unknown", organisms))

  # Color palette
  org_pal <- c(
    "Homo s" = "#4285f4",
    "Saccha" = "#34a853",
    "Escher" = "#fbbc05",
    "NA" = "#EA4335"
  )

  # Add row ID
  df_anno <- forheat %>%
    mutate(row_id = row_number())

  # ---- collect sequences for later tests ----
if (!exists("org_sequences")) org_sequences <- list()
org_sequences[[nm]] <- list(kept = df_anno$organisms, dropped = org_vec)
  
  # Plot non_missing part
  p <- ggplot(df_anno, aes(x = 1, y = row_id, fill = organisms)) +
    geom_tile() +
    scale_fill_manual(values = org_pal, name = "Organism") +
    theme_void() +
    theme(
      legend.position = "right",
      axis.text = element_blank(),
      axis.ticks = element_blank()
    )
# dropped part
  p_droped <- ggplot(df, aes(x = 1, y = row_id, fill = organism)) +
    geom_tile() +
    scale_fill_manual(
      values = org_pal,
      breaks = c("Homo s","Escher","Saccha","NA"),
      labels = c("Human","E. coli","Saccharomyces","NA"),
      name = "Organism") +
    theme_void() +
    theme(legend.position = "right")

  # 5) Save with dynamic height (so tall vectors are readable)
  h <- max(4, length(org_vec) / 200)  # tweak divisor to control density
  ggsave(paste0("../output/dropped_organisms_annotation", nm,".png"), p_droped, width = 5, height = h, dpi = 300)

  # Save image
  ggsave(paste0("../output/organisms_annotation", nm,".png"), p, , width = 5, height = h, dpi = 300)

  write.csv(result$Rectangular_element_max, paste0("../output/", nm, ".csv"))
  
  na_source <- !(tmptbl$protein_group %in% result_organism$accession)
  # tmptbl$protein_group[na_source]

  cat("##### non missing sub matrix ####")
  print(table(df_anno$organisms))
  cat("NAs    ---- >", length(which(is.na(organisms))))

  cat("##### missing remaining part ####")
  print(table(df$organism))
  cat("NAs    ---- >", length(which(is.na(organisms_drp))))
  
  result$Rectangular_element_max %>%
          as.data.frame() %>%
          colnames() %>% 
          cat()

  cat(" --------> ", nm)
}
```


```{r}
# ---------- Randomness test helpers ----------
# Count runs (consecutive blocks) in a categorical vector
count_runs <- function(x) {
  sum(c(TRUE, x[-1] != x[-length(x)]))
}

# Fraction of adjacent pairs that have the same label
adjacent_same_frac <- function(x) {
  if (length(x) <= 1) return(NA_real_)
  mean(x[-1] == x[-length(x)])
}

# Generic permutation p-value (one-sided by default for "more clustered than random")
perm_p <- function(x, stat_fun, nperm = 5000, alternative = c("less","greater","two.sided"), seed = 1L) {
  alternative <- match.arg(alternative)
  set.seed(seed)
  x <- as.character(x)
  x <- x[!is.na(x)]
  if (length(x) < 5) return(NA_real_)  # too short to test
  obs <- stat_fun(x)
  perms <- replicate(nperm, stat_fun(sample(x)))
  if (alternative == "less") {
    (sum(perms <= obs) + 1) / (nperm + 1)
  } else if (alternative == "greater") {
    (sum(perms >= obs) + 1) / (nperm + 1)
  } else {
    # two-sided
    more <- (sum(perms >= obs) + 1) / (nperm + 1)
    less <- (sum(perms <= obs) + 1) / (nperm + 1)
    2 * min(more, less)
  }
}

# Wrapper to compute both stats + p-values for one sequence
assess_randomness <- function(x, nperm = 5000, seed = 1L) {
  x <- x[!is.na(x)]
  if (length(x) < 5) {
    return(tibble::tibble(
      stat = c("runs", "adjacent_same"),
      value = NA_real_, p_value = NA_real_,
      direction = c("clustered(low runs)", "clustered(high adj-same)"),
      interpretation = "sequence too short"
    ))
  }
  # 1) Runs: clustering => fewer runs than random  => alternative = "less"
  runs_val <- count_runs(x)
  runs_p   <- perm_p(x, count_runs, nperm = nperm, alternative = "less", seed = seed)

  # 2) Adjacent-same: clustering => *higher* than random => alternative = "greater"
  adj_val <- adjacent_same_frac(x)
  adj_p   <- perm_p(x, adjacent_same_frac, nperm = nperm, alternative = "greater", seed = seed + 1)

  tibble::tibble(
    stat = c("runs", "adjacent_same"),
    value = c(runs_val, adj_val),
    p_value = c(runs_p, adj_p),
    direction = c("clustered(low runs)", "clustered(high adj-same)"),
    interpretation = dplyr::case_when(
      stat == "runs" & !is.na(p_value) & p_value < 0.05 ~ "non-random (clustered)",
      stat == "adjacent_same" & !is.na(p_value) & p_value < 0.05 ~ "non-random (clustered)",
      TRUE ~ "indistinguishable from random"
    )
  )
}

# ---------- Run tests for each dataset / matrix part ----------
results_randomness <- purrr::imap_dfr(org_sequences, function(lst, nm) {
  kept_tbl   <- assess_randomness(lst$kept,    nperm = 5000, seed = 10)
  dropd_tbl  <- assess_randomness(lst$dropped, nperm = 5000, seed = 20)
  kept_tbl  <- dplyr::mutate(kept_tbl,  matrix_part = "kept (complete submatrix)")
  dropd_tbl <- dplyr::mutate(dropd_tbl, matrix_part = "dropped (missing part)")
  dplyr::bind_rows(kept_tbl, dropd_tbl) |>
    dplyr::mutate(dataset = nm, .before = 1)
})

# Optional: add a "software" column parsed from the filename
results_randomness <- results_randomness |>
  dplyr::mutate(software = dplyr::case_when(
    grepl("compomics", dataset, ignore.case = TRUE) ~ "CompOmics",
    grepl("maxquant",  dataset, ignore.case = TRUE) ~ "MaxQuant",
    grepl("proline",   dataset, ignore.case = TRUE) ~ "Proline",
    grepl("tpp",       dataset, ignore.case = TRUE) ~ "TPP",
    TRUE ~ "Unknown"
  )) |>
  dplyr::relocate(software, dataset, matrix_part, stat, value, p_value, direction, interpretation)

# View final table
results_randomness

# --- prep ---


View(extractSubMatrix)
```
```{r}
library(dplyr)
library(tidyr)
library(glue)
library(purrr)

# 1) Add BH FDR across all tests
results_randomness_fdr <- results_randomness %>%
  mutate(p_adj = p.adjust(p_value, method = "BH")) %>%
  mutate(sig = case_when(
    is.na(p_adj) ~ NA_character_,
    p_adj < 0.001 ~ "***",
    p_adj < 0.01  ~ "**",
    p_adj < 0.05  ~ "*",
    TRUE ~ "ns"
  ))

# 2) Pick the "driver" stat per (software, dataset, matrix_part) = the smallest p_adj
driver <- results_randomness_fdr %>%
  group_by(software, dataset, matrix_part) %>%
  slice_min(order_by = p_adj, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(call = if_else(p_adj < 0.05, "non-random (clustered)", "indistinguishable from random"))

# 3) Compact table you can print in the Rmd
driver %>%
  arrange(software, matrix_part) %>%
  select(software, dataset, matrix_part, stat, value, p_value, p_adj, sig, call) -> driver_tbl

driver_tbl

```


```{r}
f_ls <- list.files("../output/", pattern = ".csv.csv")

for (lod_i in seq_along(f_ls)){
  tmp <- t(read.csv(paste0("../output/", f_ls[lod_i])))
  
  png(filename = paste0("../output/hist_", f_ls[lod_i], ".png"))
  
  # 1) Draw histogram (probability density instead of raw counts for overlay)
  hist(colMeans(tmp), breaks = 1000, probability = TRUE,
       main = paste("Histogram with Density -", f_ls[lod_i]),
       xlab = "Sum of columns")
  
  # 2) Add kernel density trend line
  lines(density(colMeans(tmp), na.rm = TRUE), col = "red", lwd = 2)
  
  # 3) (Optional) Add a normal curve for comparison
  x <- colMeans(tmp)
  curve(dnorm(x, mean = mean(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE)),
        col = "blue", lwd = 2, add = TRUE)
  
  legend("topright", legend = c("Density", "Normal fit"),
         col = c("red", "blue"), lwd = 2, bty = "n")
  
  dev.off()

}

# Assume: `tmptbl` = protein quant table with peptide counts
# and `result_organism` = mapping table with accession + organism

# Example: Add UniProt IDs + organism labels
df <- tmptbl %>%
  mutate(
    uniprot_id = protein_group,
    organism = result_organism$organism[match(protein_group, result_organism$accession)]
  ) %>%
  # keep treatment columns + labels
  select(uniprot_id, organism, starts_with("number_of_peptides_"))

```

